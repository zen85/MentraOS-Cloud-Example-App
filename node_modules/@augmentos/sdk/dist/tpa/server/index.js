"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TpaServer = void 0;
/**
 * ðŸš€ TPA Server Module
 *
 * Creates and manages a server for Third Party Apps (TPAs) in the AugmentOS ecosystem.
 * Handles webhook endpoints, session management, and cleanup.
 */
const express_1 = __importDefault(require("express"));
const path_1 = __importDefault(require("path"));
const session_1 = require("../session");
const types_1 = require("../../types");
/**
 * ðŸŽ¯ TPA Server Implementation
 *
 * Base class for creating TPA servers. Handles:
 * - ðŸ”„ Session lifecycle management
 * - ðŸ“¡ Webhook endpoints for AugmentOS Cloud
 * - ðŸ“‚ Static file serving
 * - â¤ï¸ Health checks
 * - ðŸ§¹ Cleanup on shutdown
 *
 * @example
 * ```typescript
 * class MyAppServer extends TpaServer {
 *   protected async onSession(session: TpaSession, sessionId: string, userId: string) {
 *     // Handle new user sessions here
 *     session.events.onTranscription((data) => {
 *       session.layouts.showTextWall(data.text);
 *     });
 *   }
 * }
 *
 * const server = new MyAppServer({
 *   packageName: 'org.example.myapp',
 *   apiKey: 'your_api_key'
 * });
 *
 * await server.start();
 * ```
 */
class TpaServer {
    constructor(config) {
        this.config = config;
        /** Map of active user sessions by sessionId */
        this.activeSessions = new Map();
        /** Array of cleanup handlers to run on shutdown */
        this.cleanupHandlers = [];
        // Set defaults and merge with provided config
        this.config = {
            port: 7010,
            webhookPath: '/webhook',
            publicDir: false,
            healthCheck: true,
            ...config
        };
        // Initialize Express app
        this.app = (0, express_1.default)();
        this.app.use(express_1.default.json());
        // Setup server features
        this.setupWebhook();
        this.setupHealthCheck();
        this.setupPublicDir();
        this.setupShutdown();
    }
    // Expose Express app for custom routes.
    // This is useful for adding custom API routes or middleware.
    getExpressApp() {
        return this.app;
    }
    /**
     * ðŸ‘¥ Session Handler
     * Override this method to handle new TPA sessions.
     * This is where you implement your app's core functionality.
     *
     * @param session - TPA session instance for the user
     * @param sessionId - Unique identifier for this session
     * @param userId - User's identifier
     */
    async onSession(session, sessionId, userId) {
        console.log(`New session: ${sessionId} for user ${userId}`);
    }
    /**
     * ðŸ‘¥ Stop Handler
     * Override this method to handle stop requests.
     * This is where you can clean up resources when a session is stopped.
     *
     * @param sessionId - Unique identifier for this session
     * @param userId - User's identifier
     * @param reason - Reason for stopping
     */
    async onStop(sessionId, userId, reason) {
        console.log(`Session ${sessionId} stopped for user ${userId}. Reason: ${reason}`);
        // Default implementation: close the session if it exists
        const session = this.activeSessions.get(sessionId);
        if (session) {
            session.disconnect();
            this.activeSessions.delete(sessionId);
        }
    }
    /**
     * ðŸš€ Start the Server
     * Starts listening for incoming connections and webhook calls.
     *
     * @returns Promise that resolves when server is ready
     */
    start() {
        return new Promise((resolve) => {
            this.app.listen(this.config.port, () => {
                console.log(`ðŸŽ¯ TPA server running at http://localhost:${this.config.port}`);
                if (this.config.publicDir) {
                    console.log(`ðŸ“‚ Serving static files from ${this.config.publicDir}`);
                }
                resolve();
            });
        });
    }
    /**
     * ðŸ›‘ Stop the Server
     * Gracefully shuts down the server and cleans up all sessions.
     */
    stop() {
        console.log('\nðŸ›‘ Shutting down...');
        this.cleanup();
        process.exit(0);
    }
    /**
   * ðŸ” Generate a TPA token for a user
   * This should be called when handling a session webhook request.
   *
   * @param userId - User identifier
   * @param sessionId - Session identifier
   * @param secretKey - Secret key for signing the token
   * @returns JWT token string
   */
    generateToken(userId, sessionId, secretKey) {
        const { createToken } = require('../token/utils');
        return createToken({
            userId,
            packageName: this.config.packageName,
            sessionId
        }, { secretKey });
    }
    /**
     * ðŸ§¹ Add Cleanup Handler
     * Register a function to be called during server shutdown.
     *
     * @param handler - Function to call during cleanup
     */
    addCleanupHandler(handler) {
        this.cleanupHandlers.push(handler);
    }
    /**
     * ðŸŽ¯ Setup Webhook Endpoint
     * Creates the webhook endpoint that AugmentOS Cloud calls to start new sessions.
     */
    setupWebhook() {
        if (!this.config.webhookPath) {
            console.error('âŒ Webhook path not set');
            throw new Error('Webhook path not set');
        }
        this.app.post(this.config.webhookPath, async (req, res) => {
            try {
                const webhookRequest = req.body;
                // Handle session request
                if ((0, types_1.isSessionWebhookRequest)(webhookRequest)) {
                    await this.handleSessionRequest(webhookRequest, res);
                }
                // Handle stop request
                else if ((0, types_1.isStopWebhookRequest)(webhookRequest)) {
                    await this.handleStopRequest(webhookRequest, res);
                }
                // Unknown webhook type
                else {
                    console.error('âŒ Unknown webhook request type');
                    res.status(400).json({
                        status: 'error',
                        message: 'Unknown webhook request type'
                    });
                }
            }
            catch (error) {
                console.error('âŒ Error handling webhook:', error);
                res.status(500).json({
                    status: 'error',
                    message: 'Internal server error'
                });
            }
        });
    }
    /**
     * Handle a session request webhook
     */
    async handleSessionRequest(request, res) {
        const { sessionId, userId } = request;
        console.log(`\n\nðŸ—£ï¸ Received session request for user ${userId}, session ${sessionId}\n\n`);
        // Create new TPA session
        const session = new session_1.TpaSession({
            packageName: this.config.packageName,
            apiKey: this.config.apiKey,
            augmentOSWebsocketUrl: this.config.augmentOSWebsocketUrl
        });
        // Setup session event handlers
        const cleanupDisconnect = session.events.onDisconnected(() => {
            console.log(`ðŸ‘‹ Session ${sessionId} disconnected`);
            this.activeSessions.delete(sessionId);
        });
        const cleanupError = session.events.onError((error) => {
            console.error(`âŒ [Session ${sessionId}] Error:`, error);
        });
        // Start the session
        try {
            await session.connect(sessionId);
            this.activeSessions.set(sessionId, session);
            await this.onSession(session, sessionId, userId);
            res.status(200).json({ status: 'success' });
        }
        catch (error) {
            console.error('âŒ Failed to connect:', error);
            cleanupDisconnect();
            cleanupError();
            res.status(500).json({
                status: 'error',
                message: 'Failed to connect'
            });
        }
    }
    /**
     * Handle a stop request webhook
     */
    async handleStopRequest(request, res) {
        const { sessionId, userId, reason } = request;
        console.log(`\n\nðŸ›‘ Received stop request for user ${userId}, session ${sessionId}, reason: ${reason}\n\n`);
        try {
            await this.onStop(sessionId, userId, reason);
            res.status(200).json({ status: 'success' });
        }
        catch (error) {
            console.error('âŒ Error handling stop request:', error);
            res.status(500).json({
                status: 'error',
                message: 'Failed to process stop request'
            });
        }
    }
    /**
     * â¤ï¸ Setup Health Check Endpoint
     * Creates a /health endpoint for monitoring server status.
     */
    setupHealthCheck() {
        if (this.config.healthCheck) {
            this.app.get('/health', (req, res) => {
                res.json({
                    status: 'healthy',
                    app: this.config.packageName,
                    activeSessions: this.activeSessions.size
                });
            });
        }
    }
    /**
     * ðŸ“‚ Setup Static File Serving
     * Configures Express to serve static files from the specified directory.
     */
    setupPublicDir() {
        if (this.config.publicDir) {
            const publicPath = path_1.default.resolve(this.config.publicDir);
            this.app.use(express_1.default.static(publicPath));
            console.log(`ðŸ“‚ Serving static files from ${publicPath}`);
        }
    }
    /**
     * ðŸ›‘ Setup Shutdown Handlers
     * Registers process signal handlers for graceful shutdown.
     */
    setupShutdown() {
        process.on('SIGTERM', () => this.stop());
        process.on('SIGINT', () => this.stop());
    }
    /**
     * ðŸ§¹ Cleanup
     * Closes all active sessions and runs cleanup handlers.
     */
    cleanup() {
        // Close all active sessions
        for (const [sessionId, session] of this.activeSessions) {
            console.log(`ðŸ‘‹ Closing session ${sessionId}`);
            session.disconnect();
        }
        this.activeSessions.clear();
        // Run cleanup handlers
        this.cleanupHandlers.forEach(handler => handler());
    }
}
exports.TpaServer = TpaServer;
